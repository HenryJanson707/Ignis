fn @pick_light_id(rnd: &mut RndState, num_lights: i32) {
    if ?num_lights && num_lights == 1 {
        0
    } else {
        // Note: randi() returns random integers, but we only want positive integers here
        (randi(rnd) & 0x7FFFFFFF) % num_lights
    }
}

// Returns the probability to continue given the contribution of a path
fn @russian_roulette(c: Color, clamp: f32) = clampf(2 * color_luminance(c), 0.05, clamp);

// Russian roulette used in pbrt v4
fn @russian_roulette_pbrt(c: Color, clamp: f32) = clampf(color_max_component(c), 0.05, clamp);

struct PTRayPayload {
    mis:     f32,
    contrib: Color,
    depth:   i32,
    eta:     f32
}

static AOV_PATH_NORMAL = 1;
static AOV_PATH_DIRECT = 2;
static AOV_PATH_NEE    = 3;

fn wrap_ptraypayload(payload: PTRayPayload) -> RayPayload {
    let mut r : RayPayload;
    r.components(0) = payload.mis;
    r.components(1) = payload.contrib.r;
    r.components(2) = payload.contrib.g;
    r.components(3) = payload.contrib.b;
    r.components(4) = payload.depth as f32;
    r.components(5) = payload.eta;
    r
}

fn unwrap_ptraypayload(payload: RayPayload) = PTRayPayload {
    mis     = payload.components(0),
    contrib = make_color(payload.components(1), payload.components(2), payload.components(3), 1),
    depth   = payload.components(4) as i32,
    eta     = payload.components(5),
};

fn @make_path_renderer(max_path_len: i32, num_lights: i32, lights: LightTable, aovs: AOVTable, buf: DeviceBuffer, camera_buf: DeviceBuffer, max_path_len_light: i32) -> Technique {
    let offset : f32  = 0.001;
    let pdf_lightpick = if num_lights == 0 { 1 } else { 1 / (num_lights as f32) };

    let aov_normal = @aovs(AOV_PATH_NORMAL);
    let aov_di     = @aovs(AOV_PATH_DIRECT);
    let aov_nee    = @aovs(AOV_PATH_NEE);

    // let (film_width, film_height) = device.get_film_size();
    // let buf_size = film_width * film_height * max_path_len * 16;
    // let camera_buf = device.request_buffer("camera_path", buf_size, 0);
    //let aov_stats  = @aovs(AOV_PATH_STATS);
     
    //Needs tobe checked 
    fn pdfLightDirect(current:Vertex, next:Vertex, light : DirectLightSample) -> f32{
        let unnorm_w = vec3_sub(next.pos, current.pos);
        let dist2 = vec3_dot(unnorm_w, unnorm_w);
        let dist = math_builtins::sqrt(dist2);
        let norm_w = vec3_divf(unnorm_w, dist);
        let dir_pdf = light.pdf_dir; //this needs tobe checked 
        let pdf = dir_pdf * 1/dist2;
        
        pdf * math_builtins::fabs(vec3_dot(next.normal, norm_w))
    }

    fn pdfLightEmission(current:Vertex, next:Vertex, light : EmissionValue) -> f32{
        let unnorm_w = vec3_sub(next.pos, current.pos);
        let dist2 = vec3_dot(unnorm_w, unnorm_w);
        let dist = math_builtins::sqrt(dist2);
        let norm_w = vec3_divf(unnorm_w, dist);
        let dir_pdf = math_builtins::fabs(light.pdf_dir); //this needs tobe checked 
        let pdf = dir_pdf * 1/dist2;
        pdf * math_builtins::fabs(vec3_dot(next.normal, norm_w))
    }

    //this needs tobe checked 
    fn pdfConection(current:Vertex, prev:Vertex, next:Vertex, light : DirectLightSample, isLight: bool, isCamera: bool, mat: Material) -> f32{
        if isLight{
            return(pdfLightDirect(current, next, light))
        }
        let mut pdf : f32 = 0.0;
        if isCamera{
            pdf = 1.0;
        }else{
            let wn = vec3_normalize(vec3_sub(next.pos, current.pos));
            let wp = vec3_normalize(vec3_sub(prev.pos, current.pos));
            let pdf = mat.bsdf.pdf(wp, wn); //this needs tobe checked 
        }
        return(convertDensity(current.pos, next.pos, next.normal, pdf))//this needs tobe cheked 

    }

    //this needs tobe checked 
    fn pdfConectionGround(current:Vertex, prev:Vertex, next:Vertex, mat: Material) -> f32{
        let mut pdf : f32 = 0.0;
        let wn = vec3_normalize(vec3_sub(next.pos, current.pos));
        let wp = vec3_normalize(vec3_sub(prev.pos, current.pos));
        pdf = mat.bsdf.pdf(wp, wn); //this needs tobe checked 
        return(convertDensity(current.pos, next.pos, next.normal, pdf))//this needs tobe cheked 
    }

    //Needs tobe checked 
    fn pdfLightOrigin(current:Vertex, next:Vertex, light : DirectLightSample, choicePDF : f32) -> f32{
        let w = vec3_normalize(vec3_sub(next.pos, current.pos)); //currently Useless
        let pos_pdf = light.pdf_area;
        pos_pdf * choicePDF
    }
    //wrong because we need both materials!!
    //Check this!!
    fn MISWeightS0(camBuf: DeviceBuffer, lightBuf: DeviceBuffer, pixel:i32, t:i32, pdfLightpick: f32, light: EmissionValue) -> f32{
        //The current size of one data point is 16 bytes (valid: i32 (0, 1): 0, material: i32: 1, pdfFwd: f32 : 2, pdfRev: f32: 3, pos: vec3 : 4, normal: vec3 : 7, beta: vec3 : 10, wo: vec3 : 13)
        let startCamBuff = 16 * pixel * max_path_len;
        let startLightBuf = 16 * pixel * max_path_len_light;
        let mut pt = if t > 0 {load_vertex(camBuf, startCamBuff + 16 * (t-1))} else {make_empty_Vertex()};
        let mut ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + 16 * (t-2))} else {make_empty_Vertex()};

        let mut sumRi : f32 = 0.0;

        let mut ri : f32 = 1.0;

        // print_string("\n");
        // print_f32(pdfLightpick * light.pdf_area);
        // print_string("\n");
        // if pt.pdfFwd < 0.0{
        //     print_string("\n");
        //     print_f32(pt.pdfFwd);
        //     print_string("\n");
        // }
        if pt.valid != 0 && t - 1 > 1{
            let ptPdfRev = pdfLightpick * light.pdf_area; //pdfLightOrigin
            ri *= ptPdfRev / pt.pdfFwd;
            sumRi += ri;
        }
        if ptMinus.valid != 0 && t - 2 > 1{
            let ptMinusPdfRev = pdfLightEmission(pt, ptMinus, light);
            ri *= ptMinusPdfRev / ptMinus.pdfFwd;
            sumRi += ri;
        }

        
        //this could be wrong???
        let mut i = t-3;
        while i > 1{
            ri *= load_vertex_pdfRev(camBuf, startCamBuff + 16 * i) / load_vertex_pdfFwd(camBuf, startCamBuff + 16 * i);
            sumRi += ri;
            i -= 1;
        }

        // if(t == 2){
        //     print_f32(pt.pdfFwd);
        // }
        
        // for i in range_step(t-3, 1, -1){
        //     //this just seems wrong
        //     //ri *= camBuf.load_f32(startCamBuff + 16 * i + 3) / camBuf.load_f32(startCamBuff + 16 * i + 2);
        //     //This is most likly wrong
        //     print_i32(i);
        //     ri *= load_vertex_pdfRev(camBuf, startCamBuff + 16 * i) / load_vertex_pdfFwd(camBuf, startCamBuff + 16 * i);
        //     sumRi += ri;
        // }

        return(1.0 / (1.0 + sumRi))
    }
    //wrong because we need both materials!!
    //Check this!!
    fn MISWeightS1(camBuf: DeviceBuffer, lightBuf: DeviceBuffer, pixel:i32, t:i32, light: DirectLightSample, mat: Material, sampled: Vertex) -> f32{
        //The current size of one data point is 16 bytes (valid: i32 (0, 1): 0, material: i32: 1, pdfFwd: f32 : 2, pdfRev: f32: 3, pos: vec3 : 4, normal: vec3 : 7, beta: vec3 : 10, wo: vec3 : 13)
        let startCamBuff = 16 * pixel * max_path_len;
        let startLightBuf = 16 * pixel * max_path_len_light;
        let mut pt = if t > 0 {load_vertex(camBuf, startCamBuff + 16 * (t-1))} else {make_empty_Vertex()};
        let mut ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + 16 * (t-2))} else {make_empty_Vertex()};
        let qs = sampled;

        let mut sumRi : f32 = 0.0;

        let mut ri :f32 = 1.0;

        if pt.valid != 0 && t - 1 > 1{
            let ptPdfRev = pdfLightDirect(qs, pt, light); //this is most likly wrong 
            ri *= ptPdfRev / pt.pdfFwd;
            sumRi += ri;
        }

        if ptMinus.valid != 0 && t - 2 > 1{
            let ptMinusPdfRev = pdfConectionGround(pt, qs, ptMinus, mat);
            ri *= ptMinusPdfRev / ptMinus.pdfFwd;
            sumRi += ri;
        }
        // if sumRi < 0.000001{
        //     print_string("\n");
        //     print_i32(t);
        //     print_string("\n");
        // }

        //this could be wrong???
        let mut i = t-3;
        while i > 1{
            ri *= load_vertex_pdfRev(camBuf, startCamBuff + 16 * i) / load_vertex_pdfFwd(camBuf, startCamBuff + 16 * i);
            sumRi += ri;
            i -= 1;
        }


        // print_string("\n");
        // print_f32(sumRi);
        // print_string("\n");

        // for i in range_step(t-3, 1, -1){
        //     //this just seems wrong
        //     //ri *= camBuf.load_f32(startCamBuff + 16 * i + 3) / camBuf.load_f32(startCamBuff + 16 * i + 2);
        //     //This is most likly wrong
        //     ri *= load_vertex_pdfRev(camBuf, startCamBuff + 16 * i) / load_vertex_pdfFwd(camBuf, startCamBuff + 16 * i);
        //     sumRi += ri;
        // }

        ri = 1.0;

        let qsPdfRev = pdfConectionGround(pt, ptMinus, qs, mat);
        ri *= qsPdfRev / qs.pdfFwd;
        sumRi += ri;

        return(1.0 / (1.0 + sumRi))
    }
    //wrong because we need both materials!!
    fn MISWeight(camBuf: DeviceBuffer, lightBuf: DeviceBuffer, pixel:i32, s:i32, t:i32, mat: Material) -> f32{
        let startCamBuff = 16 * pixel * max_path_len;
        let startLightBuf = 16 * pixel * max_path_len_light;
        // let current_buf_pos = buf_pos + pt.depth * 16;
        let mut qs = load_vertex(lightBuf, startLightBuf + 16 * (s-1));
        let mut pt = if t > 0 {load_vertex(camBuf, startCamBuff + 16 * (t-1))} else {make_empty_Vertex()};
        let mut qsMinus = load_vertex(lightBuf, startLightBuf + 16 * (s-2));
        let mut ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + 16 * (t-2))} else {make_empty_Vertex()};

        let mut sumRi : f32 = 0.0;

        let mut ri :f32 = 1.0;

        //i think the ifs are useless

        if pt.valid != 0 && t - 1 > 1{
            let ptPdfRev = pdfConectionGround(qs, qsMinus, pt, mat); //this is most likly wrong 
            ri *= ptPdfRev / pt.pdfFwd;
            sumRi += ri;
        }
        if ptMinus.valid != 0 && t - 2 > 1{
            let ptMinusPdfRev = pdfConectionGround(pt, qs, ptMinus, mat);
            ri *= ptMinusPdfRev / ptMinus.pdfFwd;
            sumRi += ri;
        }

        for i in range_step(t-3, 1, -1){
            //this just seems wrong
            //ri *= camBuf.load_f32(startCamBuff + 16 * i + 3) / camBuf.load_f32(startCamBuff + 16 * i + 2);
            //This is most likly wrong
            ri *= load_vertex_pdfRev(camBuf, startCamBuff + 16 * i) / load_vertex_pdfFwd(camBuf, startCamBuff + 16 * i);
            sumRi += ri;
        }

        ri = 1.0;
        
        let qsPdfRev = pdfConectionGround(pt, ptMinus, qs, mat);
        ri *= qsPdfRev / qs.pdfFwd;
        sumRi += ri;

        let qsMinusPdfRev = pdfConectionGround(qs, pt, qsMinus, mat);
        ri *= qsMinusPdfRev / qsMinus.pdfFwd;
        sumRi += ri;

        let mut i = t-3;
        //this could be wrong???
        while i > -1{
            ri *= load_vertex_pdfRev(lightBuf, startLightBuf + 16 * i) / load_vertex_pdfFwd(lightBuf, startLightBuf + 16 * i); //Extra check here
            sumRi += ri;
            i -= 1;
        }

        // for i in range_step(t-3, -1, -1){
        //     //this just seems wrong 
        //     //there might be a mistake here because of the case 0
        //     //ri *= lightBuf.load_f32(startLightBuf + 16 * i + 3) / lightBuf.load_f32(startLightBuf + 16 * i + 2);
        //     //This is most likly wrong
        //     ri *= load_vertex_pdfRev(lightBuf, startLightBuf + 16 * i) / load_vertex_pdfFwd(lightBuf, startLightBuf + 16 * i); //Extra check here
        //     sumRi += ri;
        // }

        return(1.0 / (1.0 + sumRi))
    }    


    fn @on_shadow( ray: Ray
                 , pixel: i32
                 , _hit: Hit
                 , rnd: &mut RndState
                 , payload: RayPayload
                 , surf: SurfaceElement
                 , mat: Material
                 ) -> ShadowRay {
        
        if num_lights == 0{
            return(ShadowRay::None)
        }

        let pt = unwrap_ptraypayload(payload);

        if pt.depth >= max_path_len {
            return(ShadowRay::None)
        }

        let light_buf_pos  = 16 * pixel * max_path_len_light;
        let camera_buf_pos = 16 * pixel * max_path_len;

        let light_path_len = load_vertex_valid(buf, light_buf_pos);

        let choice = if light_path_len == 0 {1} else {pick_light_id(rnd, light_path_len) + 1};
        //let s = if light_path_len >= 2 {2} else {0}; //important currently there is no choice here!!!!
        let s = 0;
        //let s = 2;
        //let s = 1;
        let t = pt.depth;
        if s == 1{
            let light_id      = pick_light_id(rnd, num_lights);
            let light         = @lights(light_id);//sollte eventuel wie im normalen pathtracer angepasst werden!!
            let sample_direct = light.sample_direct;
            let light_sample  = @sample_direct(rnd, surf);
            let light_pdf     = 1 / (num_lights as f32);


            if light.infinite{
                return(ShadowRay::None)
            }else{
                if light_sample.pdf_area <= flt_eps{
                    return(ShadowRay::None)
                }
                let light_dir = vec3_sub(light_sample.posdir, surf.point);
                let light_dist = vec3_len(light_dir);
                let light_dist2 = light_dist * light_dist;
                let wi = vec3_mulf(light_dir, 1/light_dist);
                let wo = vec3_neg(ray.dir);

                let vis = vec3_dot(light_dir, surf.local.col(2));
                // if vis > flt_eps && light_sample.cos > flt_eps && pt.depth == 2{
                if vis > flt_eps && light_sample.cos > flt_eps{
                    let cos_l = light_sample.cos;
                    let pdf_area = light_sample.pdf_area;
                    //TODO can we use cos_l here???
                    let pdf_dirpos = pdf_area * light_dist2 / (cos_l);

                    let light_beta = color_mulf(light_sample.intensity, 1/(pdf_dirpos * light_pdf));
                    let f = mat.bsdf.eval(wi, wo); //Ich gehe davon aus das hier auch schon Cos drinnen ist?
                    let contri = color_mul(color_mul(light_beta, pt.contrib), f);
                    // if(pixel == 468613){
                    //     print_string("\n");
                    //     print_f32(1/pdf_dirpos);
                    //     print_string("\n");
                    //     print_f32(light_sample.pdf_area);
                    //     print_string("\n");
                    //     print_f32(pdf_lightpick);
                    //     print_string("\n");
                    //     print_f32(cos_l);
                    //     print_string("\n");
                    //     print_f32(1/light_dist2);
                    //     print_string("\n");
                    // }
                    //There are some felds missing like normal and dir is that important?????
                    let mut sampled = make_empty_Vertex();
                    sampled.valid = 1;
                    sampled.pos = light_sample.posdir;
                    sampled.beta = light_beta;
                    let mut pt = make_empty_Vertex();
                    //this should be enuqgh but im not quit shoure 
                    pt.valid = 1;
                    pt.pos = surf.point;
                    //we neeed pt wich should be the current Vertex??
                    sampled.pdfFwd = pdfLightOrigin(sampled, pt, light_sample, pdf_lightpick);//is the order corect here?//and dont we need corection
                    //i hope we dont need the normal!!!!

                    let mis = MISWeightS1(camera_buf, buf, pixel, t, light_sample, mat, sampled);
                    // print_string("\n");
                    // print_f32(mis);
                    // print_string("\n");
                    return(make_simple_shadow_ray(
                        make_ray(surf.point, light_dir, offset, 1 - offset),
                        contri
                    ))
                }else{
                    return(ShadowRay::None)
                }
            }
        }else if s > 1{
            let camera_pos = surf.point;
            let camera_wo = vec3_neg(ray.dir);
            let camera_beta = pt.contrib;

            let light_buf_pos_corrected = light_buf_pos + 16 * (s - 1);

            let light_vertex = load_vertex(buf, light_buf_pos_corrected);
            //The current size of one data point is 16 bytes (valid: i32 (0, 1): 0, material: i32: 1, pdfFwd: f32 : 2, pdfRev: f32: 3, pos: vec3 : 4, normal: vec3 : 7, beta: vec3 : 10, wo: vec3 : 13)
            let light_pos = light_vertex.pos;
            let light_normal = light_vertex.normal;
            let light_beta = light_vertex.beta;
            let light_wi = light_vertex.wo;

            let light_dir = vec3_sub(light_pos, camera_pos);
            let light_dist = vec3_len(light_dir);
            let light_dist2 = light_dist * light_dist;

            let camera_wi = vec3_mulf(light_dir, 1/light_dist);
            let light_wo = vec3_neg(camera_wi);
            
            let vis_camera = vec3_dot(camera_wi, surf.face_normal);
            let vis_camera2 = vec3_dot(camera_wo, surf.face_normal);
            let vis_light = vec3_dot(light_wo, light_normal);
            let vis_light2 = vec3_dot(light_wi, light_normal);
            // if vis_camera > flt_eps && vis_camera2 > flt_eps && vis_light > flt_eps && vis_light2 > flt_eps && pt.depth == 1{
            if vis_camera > flt_eps && vis_camera2 > flt_eps && vis_light > flt_eps && vis_light2 > flt_eps{ 
                let light_surf = SurfaceElement{
                    is_entering = true,
                    point = light_pos,
                    face_normal = light_normal,
                    inv_area = 1, //TODO this is wrong but should not matter 
                    prim_coords = make_vec2(0,0),
                    tex_coords = make_vec2(0,0),
                    local = make_orthonormal_mat3x3(light_normal)
                };

                let light_mat = make_diffuse_bsdf(light_surf, make_color(1,1,1,1));

                let geom_factor = 1 / light_dist2; //the two cos factors should be in in the two bsdf calculations
                let camera_bsdf = mat.bsdf.eval(camera_wi, camera_wo);

                let light_bsdf = light_mat.eval(light_wo, light_wi); 
                let conection = color_mulf(color_mul(camera_bsdf, light_bsdf), geom_factor);
                let contri = color_mul(color_mul(conection, camera_beta), light_beta);
            
                // if(pixel == 125864){
                //     print_string("Camera");
                //     // print_string("\n");
                //     // print_f32(light_dist);
                //     // print_string("\n");
                //     // print_f32(geom_factor);
                //     // print_string("\n");
                //     // print_f32(light_bsdf.r);print_string(",");print_f32(light_bsdf.g);print_string(",");print_f32(light_bsdf.b);print_string(",");
                //     // print_string("\n");
                //     // print_f32(conection.r);print_string(",");print_f32(conection.g);print_string(",");print_f32(conection.b);print_string(",");
                //     print_string("\n");
                //     print_f32(light_pos.x);print_string(",");print_f32(light_pos.y);print_string(",");print_f32(light_pos.z);print_string(",");
                //     // print_string("\n");
                //     // print_f32(surf.point.x);print_string(",");print_f32(surf.point.y);print_string(",");print_f32(surf.point.z);print_string(",");
                //     print_string("\n");
                //     print_f32(light_normal.x);print_string(",");print_f32(light_normal.y);;print_string(",");print_f32(light_normal.z);;print_string(",");
                //     // print_string("\n");
                //     // print_f32(surf.face_normal.x);print_string(",");print_f32(surf.face_normal.y);;print_string(",");print_f32(surf.face_normal.z);;print_string(",");
                //     print_string("\n");
                //     print_f32(light_beta.r);print_string(",");print_f32(light_beta.g);print_string(",");print_f32(light_beta.b);print_string(",");
                //     print_string("\n");
                //     print_f32(light_wi.x);print_string(",");print_f32(light_wi.y);print_string(",");print_f32(light_wi.z);print_string(",");
                //     print_string("\n");
                //     print_f32(light_wo.x);print_string(",");print_f32(light_wo.y);print_string(",");print_f32(light_wo.z);print_string(",");
                //     // print_string("\n");
                //     // print_f32(contri.r);print_string(",");print_f32(contri.g);print_string(",");print_f32(contri.b);print_string(",");
                //     print_string("\n");
                //     print_flush();
                // }

                //return(Option[(Ray, Color)]::None)
                return(make_simple_shadow_ray(
                    make_ray(surf.point, light_dir, offset, 1 - offset),
                    contri
                ))
            }else{
                ShadowRay::None
            }
        }else{
            ShadowRay::None
        }
    }

    fn @on_hit( ray: Ray
              , pixel: i32
              , hit: Hit
              , payload: RayPayload
              , surf: SurfaceElement
              , mat: Material
              ) -> Option[Color] {
        let pt = unwrap_ptraypayload(payload);
        // if pt.depth == 1 {
        //     aov_normal.splat(pixel, make_color(math_builtins::fabs(surf.local.col(2).x),
        //                                        math_builtins::fabs(surf.local.col(2).y),
        //                                        math_builtins::fabs(surf.local.col(2).z),
        //                                        1));
        // }
        
        // if pt.depth == 1 && pixel == 186791{
        //     print_string("\n");
        //     print_f32(ray.org.z);
        //     print_string("\n");
        // }


        let wo = vec3_neg(ray.dir);
        let buf_pos = 16 * pixel * max_path_len;

        let beta = pt.contrib;
        //it need to retestet if the first pdfFwd = 1.0 ist!!!
        let pdfFwd = if pt.depth == 1 {1.0} else {pt.mis}; //this seems wrong but it could work????
        
        // let rr_prob = russian_roulette_pbrt(color_mulf(pt.contrib, pt.eta * pt.eta), 0.95);
        // if pt.depth + 1 > max_path_len || randf(rnd) >= rr_prob {
        //     return(Option[(Ray, RayPayload)]::None)
        // }
        
        let current_buf_pos = buf_pos + pt.depth * 16;
        let prev_buf_pos = buf_pos + (pt.depth - 1) * 16;
        // let contrib     = color_mul(pt.contrib, mat_sample.color/* Pdf and cosine are already applied!*/);
        // let mis         = if mat.bsdf.is_specular { 0 } else { 1 / mat_sample.pdf };
        // let new_contrib = color_mulf(contrib, 1 / rr_prob);

        let current_pos = surf.point;
        let current_normal = surf.face_normal;
        
        
        let prev_vertex     = load_vertex(camera_buf, prev_buf_pos);
        let prev_pos        = if pt.depth == 1 {ray.org} else {prev_vertex.pos}; //this should fix the problem with pt.depth == 0 problem but is not the best way!!
        
        //Currently this is wrong because 0 prev_pos is wrong because its not currently known for pt.depth = 0
        let mut correctedFwdPDF = convertDensity(prev_pos, current_pos, current_normal, pdfFwd);

        //TODO this seems to be a wrong way of handeling this problem

        //The current size of one data point is 16 bytes (valid: i32 (0, 1): 0, material: i32: 1, pdfFwd: f32 : 2, pdfRev: f32: 3, pos: vec3 : 4, normal: vec3 : 7, beta: vec3 : 10, wo: vec3 : 13)
        
        let current_vertex = Vertex {
            valid =      1,
            mat =        -1,
            pdfFwd =     correctedFwdPDF,
            pdfRev =     0.0,
            pos =        current_pos,
            normal =     current_normal,
            beta =       beta,
            wo =         wo
        };
        store_vertex(camera_buf, current_buf_pos, current_vertex);
        //store_vertex_data(camera_buf, current_buf_pos, 1, -1, correctedFwdPDF, 0.0, current_pos, current_normal, beta, wo);

        // Hits on a light source
        if mat.is_emissive && surf.is_entering {
            let out_dir = vec3_neg(ray.dir);
            let dot     = vec3_dot(out_dir, surf.local.col(2));
            if dot > flt_eps { // Only contribute proper aligned directions
                let emit     = mat.emission(out_dir);
                // let next_mis = pt.mis * hit.distance * hit.distance / dot;
                // let mis      = 1 / (1 + next_mis * pdf_lightpick * emit.pdf_area);
                // let contrib  = color_mulf(color_mul(pt.contrib, emit.intensity), mis);
                
                // //aov_di.splat(pixel, contrib);
                let current_pos = surf.point;
                let current_light = mat.emission(current_pos);
                let contrib = color_mul(pt.contrib, emit.intensity);
                let mis = MISWeightS0(camera_buf, buf, pixel, pt.depth, pdf_lightpick, current_light); //the pt.depth thing is motlikly wrong
                // if mis < 0.000001{
                //     print_string("\n");
                //     print_i32(pt.depth);
                //     print_string("\n");
                //     print_f32(mis);
                //     print_string("\n");
                // }
                //return(make_option(color_mulf(contrib,mis)))
                return(make_option(contrib))
                //return(Option[Color]::None)
                // if pt.depth == 1{
                //     return(make_option(contrib))
                // }else{
                //     return(Option[Color]::None)
                // }
            }
        }
        Option[Color]::None
    }

    fn @on_miss( ray: Ray
               , pixel: i32
               , payload: RayPayload) -> Option[Color] {
        // let mut inflights = 0;
        // let mut color     = black;

        // // Due to the renderer design, this will only iterate through
        // // infinite lights, as a miss shader does not contain area lights
        // for light_id in unroll(0, num_lights) {
        //     let light = @lights(light_id);
        //     // Do not include delta lights or finite lights
        //     if light.infinite && !light.delta {
        //         let pt = unrap_ptraypayload(payload);

        //         inflights += 1;

        //         let out_dir = vec3_neg(ray.dir);
        //         let emit    = light.emission(out_dir, make_invalid_surface_element());
        //         let mis     = 1 / (1 + pt.mis * pdf_lightpick * emit.pdf_dir);
        //         color = color_add(color, color_mulf(color_mul(pt.contrib, emit.intensity), mis));
        //     }
        // }

        // if inflights > 0 {
        //     aov_di.splat(pixel, color);
        //     make_option(color)
        // } else {
        //     Option[Color]::None
        // }
        Option[Color]::None
    }

    fn @on_bounce( ray: Ray
                 , pixel: i32
                 , _hit: Hit
                 , rnd: &mut RndState
                 , payload: RayPayload
                 , surf: SurfaceElement
                 , mat: Material
                 ) -> Option[(Ray, RayPayload)] {
        let pt = unwrap_ptraypayload(payload);
        
        if pt.depth + 1 > max_path_len {
            return(Option[(Ray, RayPayload)]::None)
        }

        if pt.depth >= max_path_len {
            return(Option[(Ray, RayPayload)]::None)
        }

        let buf_pos = 16 * pixel * max_path_len;
        let prev_buf_pos = buf_pos + (pt.depth - 1) * 16;

        //print_i32(pt.depth);
        // aov_stats.splat(pixel, make_color(if pt.depth == 1 { 2 } else { 1 }, 0, 0));
        // Bounce
        let wo = vec3_neg(ray.dir);
        let beta = pt.contrib;
        let current_pos = surf.point;

        if let Option[BsdfSample]::Some(mat_sample) = mat.bsdf.sample(rnd, wo, false) {
            let next_pdf = mat_sample.pdf;
            if next_pdf == 0.0{
                return(Option[(Ray, RayPayload)]::None)
            }
            let next_contri = color_mul(beta, mat_sample.color); //cos and pdf is already applied

            let prev_vertex     = load_vertex(camera_buf, prev_buf_pos);

            let prev_pos        = prev_vertex.pos;
            let prev_normal     = prev_vertex.normal;

            let mut correctedRevPDF : f32 = 0.0;
            let pdfRev = mat.bsdf.pdf(mat_sample.in_dir, wo); //this could be wrong!!!!

            if pt.depth != 1{
                correctedRevPDF = convertDensity(current_pos, prev_pos, prev_normal, pdfRev);
            }

            store_vertex_pdfRev(camera_buf, prev_buf_pos, correctedRevPDF);

            make_option(
                make_ray(surf.point, mat_sample.in_dir, offset, flt_max),
                wrap_ptraypayload(PTRayPayload {
                    mis     = next_pdf,
                    contrib = next_contri,
                    depth   = pt.depth + 1,
                    eta     = pt.eta * mat_sample.eta
                })
            )
        } else {
            Option[(Ray, RayPayload)]::None
        }
    }

    fn @on_shadow_miss( _ray: Ray
                      , pixel: i32
                      , color: Color) -> Option[Color] {
        aov_nee.splat(pixel, color);
        make_option(color)
    }

    Technique {
        on_hit         = on_hit,
        on_miss        = on_miss,
        on_shadow      = on_shadow,
        on_bounce      = on_bounce,
        on_shadow_hit  = TechniqueNoShadowHitFunction,
        on_shadow_miss = on_shadow_miss,
    }
}
