fn @make_light_camera(tmin: f32, tmax: f32, buf: DeviceBuffer, num_lights: i32, lights: LightTable, max_path_len: i32){
    let pdf_pick = 1 / (num_lights as f32);

    Camera {
        generate_ray = @ |_, _, pixel, rnd| {
            let mut temp_rand   = rnd; //maybe faster to just give a mutable random value
            let light_id        = pick_light(&mut temp_rand, num_lights);
            let light           = @lights(light_id);
            let sample_emission = light.sample_emission;
            let light_sample    = @sample_emission(&mut temp_rand);
            //TODO this is worng
            let mis             = light_sample.pdf_area * light_sample.pdf_dir * pdf_pick * light_sample.cos;
            let pos             = light_sample.pos;
            let dir             = light_sample.dir;
            let intensity       = color_to_vec3(light_sample.intensity);
            
            let current_pos     = pixel * 12 * max_path_len;
            
            //The current size of one data point is 12 bytes (valid: i32 (0, 1), material: i32, pdf: f32, pos: vec3, dir: vec3, intensity: vec3)
            buf.store_int2(current_pos, 1, -1); //Has the light a material???
            buf.store_f32(current_pos + 2, mis);
            buf.store_vec3(current_pos + 3, pos);
            buf.store_vec3(current_pos + 6, dir);
            buf.store_vec3(current_pos + 9, intensity);
            make_ray(pos, dir, tmin, tmax)
        }
    }
}

// Creates a perspective camera
fn @make_perspective_camera(eye: Vec3, view: Mat3x3, w: f32, h: f32, tmin: f32, tmax: f32) -> Camera {
    let dir   = view.col(2);
    let right = view.col(0);
    let up    = view.col(1);

    Camera {
        generate_ray = @ |x, y, _, _| {
            let d = vec3_normalize(
                vec3_add(
                    vec3_add(vec3_mulf(right, w * x),
                             vec3_mulf(up, h * y)),
                    dir
                )
            );
            make_ray(eye, d, tmin, tmax)
        }
    }
}

// Creates an orthogonal camera
fn @make_orthogonal_camera(eye: Vec3, view: Mat3x3, w: f32, h: f32, tmin: f32, tmax: f32) -> Camera {
    let dir   = view.col(2);
    let right = view.col(0);
    let up    = view.col(1);

    Camera {
        generate_ray = @ |x, y, _, _| {
            let pos = vec3_add(
                            vec3_add(vec3_mulf(right, w * x),
                                    vec3_mulf(up, h * y)),
                            eye
                      );
            make_ray(pos, dir, tmin, tmax)
        }
    }
}

enum FisheyeAspectMode {
    Circular,
    Cropped,
    Full
}

// Creates a fishlens camera
fn @make_fishlens_camera(eye: Vec3, view: Mat3x3, w: f32, h: f32, tmin: f32, tmax: f32) -> Camera {
    let fov = flt_pi;
    let asp = w / h;
    
    let mode = FisheyeAspectMode::Circular;

    // Select aspect ratio mode
    let (xasp, yasp) = match(mode) {
        FisheyeAspectMode::Circular => {
            let xasp = if asp < 1 { 1 } else { asp };
            let yasp = if asp > 1 { 1 } else { asp };
            (xasp, yasp)
        },
        FisheyeAspectMode::Cropped => {
            let xasp = if asp < 1 { 1 / asp } else { 1 };
            let yasp = if asp > 1 { 1 / asp } else { 1 };
            (xasp, yasp)
        },
        FisheyeAspectMode::Full => {
            let diameter = math_builtins::sqrt(asp * asp + 1) * h;
            let min_s	 = math_builtins::fmin(w, h);
            let f        = diameter / min_s;
            let xasp = if asp < 1 { f } else { f / asp };
            let yasp = if asp > 1 { f } else { f * asp };
            (xasp, yasp)
        }
    };

    Camera {
        generate_ray = @ |x, y, _, _| {
            let nx    = x * xasp;
            let ny    = y * yasp;
            let r	  = math_builtins::sqrt(nx * nx + ny * ny);
		    let theta = r * fov / 2;

		    let sT = math_builtins::sin(theta);
            let cT = math_builtins::cos(theta);
            let sP = if r < flt_eps { 0 } else { ny / r };
            let cP = if r < flt_eps { 0 } else { nx / r };
            let nd = make_vec3(sT*cP, sT*sP, cT);
            let d  = vec3_normalize(mat3x3_mul(view, nd));
            make_ray(eye, d, tmin, tmax)
        }
    }
}
