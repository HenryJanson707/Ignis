//TODO this can be done better
struct SecondaryPayload{
    s: i32,
    t: i32,
    ri: Vec2,
    light_wo: Vec3,
    camera_pos: Vec3,
}
//TODO this can be done better
fn @write_secondarypayload(payload: RayPayload, pt: SecondaryPayload){
    payload.set(0, pt.s as f32);
    payload.set(1, pt.t as f32);
    payload.set(2, pt.ri.x);
    payload.set(3, pt.ri.y);
    payload.set(4, pt.light_wo.x);
    payload.set(5, pt.light_wo.y);
    payload.set(6, pt.light_wo.z);
    payload.set(7, pt.camera_pos.x);
    payload.set(8, pt.camera_pos.y);
    payload.set(9, pt.camera_pos.z);
}
//TODO this can be done better
fn @unwrap_secondarypayload(payload: RayPayload) -> SecondaryPayload {
    SecondaryPayload {
        s = payload.get(0) as i32, //is this realy okay???
        t = payload.get(1) as i32,
        ri = make_vec2(payload.get(2), payload.get(3)),
        light_wo = make_vec3(payload.get(4), payload.get(5), payload.get(6)),
        camera_pos =  make_vec3(payload.get(7), payload.get(8), payload.get(9)),
    }
}

struct BIRayPayload {
    mis:     f32,
    contrib: Color,
    depth:   i32,
    eta:     f32
}

fn @write_biraypayload(payload: RayPayload, pt: BIRayPayload) {
    payload.set(0, pt.mis);
    payload.set(1, pt.contrib.r);
    payload.set(2, pt.contrib.g);
    payload.set(3, pt.contrib.b);
    payload.set(4, pt.depth as f32);
    payload.set(5, pt.eta);
}

fn @unwrap_biraypayload(payload: RayPayload) -> BIRayPayload {
    BIRayPayload {
        mis     = payload.get(0),
        contrib = make_color(payload.get(1), payload.get(2), payload.get(3), 1),
        depth   = payload.get(4) as i32,
        eta     = payload.get(5)
    }
}

fn @init_biraypayload(payload: RayPayload) = write_biraypayload(payload,
    BIRayPayload {
        mis = 0,
        contrib = color_builtins::white,
        depth   = 1,
        eta     = 1
    });

fn @make_bi_renderer(max_path_len: i32, light_selector: LightSelector, aovs: AOVTable, buf: DeviceBuffer, camera_buf: DeviceBuffer, max_path_len_light: i32, camera: Camera, width: i32, height: i32) -> Technique {
    let pdf_lightpick = if light_selector.count > 0 {1.0 / (light_selector.count as f32)} else {1.0};
    let offset : f32  = 0.001;

    let aov0 = @aovs(2);
    let aov1 = @aovs(3);
    let aov2 = @aovs(4);
    let aov3 = @aovs(5);
    let aovNone = @aovs(-1); //this should be empty
    fn get_aov(n: i32){
        if n == 0{
            aov0
        }else if n == 1{
            aov1
        }else if n == 2{
            aov2
        }else if n == 3{
            aov3 
        }else{
            aovNone
        }
    }
     
    fn pdfLightDirect(current:Vertex, next:Vertex, light_pdf : EmissivePdf) -> f32{
        let unnorm_w = vec3_sub(next.pos, current.pos);
        let dist2 = vec3_dot(unnorm_w, unnorm_w);
        let dist = math_builtins::sqrt(dist2);
        let norm_w = vec3_divf(unnorm_w, dist);
        let dir_pdf = light_pdf.pdf_dir; //the pdf is dir pdf
        let pdf = dir_pdf * 1/dist2;
        
        pdf * math_builtins::fabs(vec3_dot(next.normal, norm_w))
    }

    fn pdfLightEmission(current:Vertex, next:Vertex, light_pdf : EmissivePdf) -> f32{
        let unnorm_w = vec3_sub(next.pos, current.pos);
        let dist2 = vec3_dot(unnorm_w, unnorm_w);
        let dist = math_builtins::sqrt(dist2);
        let norm_w = vec3_divf(unnorm_w, dist);
        let dir_pdf = math_builtins::fabs(light_pdf.pdf_dir); //the pdf is dir pdf
        let pdf = dir_pdf * 1/dist2;
        pdf * math_builtins::fabs(vec3_dot(next.normal, norm_w))
    }

    fn pdfConectionGround(current:Vertex, prev:Vertex, next:Vertex, mat: Material) -> f32{
        let mut pdf : f32 = 0.0;
        let wn = vec3_normalize(vec3_sub(next.pos, current.pos));
        let wp = vec3_normalize(vec3_sub(prev.pos, current.pos));
        pdf = mat.bsdf.pdf(wp, wn); //this needs tobe checked 
        return(convertDensity(current.pos, next.pos, next.normal, pdf))
    }

    fn _pdfConectionGroundPrint(current:Vertex, prev:Vertex, next:Vertex, mat: Material) -> f32{
        let mut pdf : f32 = 0.0;
        let wn = vec3_normalize(vec3_sub(next.pos, current.pos));
        let wp = vec3_normalize(vec3_sub(prev.pos, current.pos));
        pdf = mat.bsdf.pdf(wp, wn); 
        print_f32(pdf);
        return(convertDensity(current.pos, next.pos, next.normal, pdf))
    }

    //TODO check this!!!
    fn pdfLightOrigin(_current:Vertex, _next:Vertex, light_pdf:EmissivePdf, choicePDF : f32) -> f32{
        //let w = vec3_normalize(vec3_sub(next.pos, current.pos)); //currently Useless
        let pos_pdf = light_pdf.pdf_area; //pdf is Pos/Area
        pos_pdf * choicePDF
    }

    fn @misSaveDiv(f1: f32, f2: f32) -> f32{
        let s1 = if f1 > flt_eps {f1} else {1.0};
        let s2 = if f2 > flt_eps {f2} else {1.0};
        s1 / s2
    }

    //wrong because we need both materials!!
    //Check this!!
    fn MISWeightS0(camBuf: DeviceBuffer, _lightBuf: DeviceBuffer, pixel:i32, t:i32, pdfLightpick: f32, light_pdf : EmissivePdf) -> f32{
        let startCamBuff = vertex_size * pixel * max_path_len;
        //let startLightBuf = vertex_size * pixel * max_path_len_light;
        let pt = if t > 0 {load_vertex(camBuf, startCamBuff + vertex_size * (t-1))} else {make_empty_Vertex()};
        let ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + vertex_size * (t-2))} else {make_empty_Vertex()};

        let mut sumRi : f32 = 0.0;

        let mut ri : f32 = 1.0;

        if pt.valid != 0 && t - 1 > 1{
            let ptPdfRev = pdfLightpick * light_pdf.pdf_area; 
            ri *= misSaveDiv(ptPdfRev, pt.pdfFwd);
            if ptMinus.isDelta == 0{ 
                sumRi += ri;
            }
        }
        if ptMinus.valid != 0 && t - 2 > 1{
            let ptMinusPdfRev = pdfLightEmission(pt, ptMinus, light_pdf);
            ri *= misSaveDiv(ptMinusPdfRev, ptMinus.pdfFwd);
            if ptMinus.isDelta == 0 && load_vertex_isDelta(camBuf, startCamBuff + vertex_size * (t-3)) == 0{
                sumRi += ri;
            }
        }

        //this could be wrong???
        let mut i = t-3;
        while i > 1{
            ri *= misSaveDiv(load_vertex_pdfRev(camBuf, startCamBuff + vertex_size * i), load_vertex_pdfFwd(camBuf, startCamBuff + vertex_size * i));
            if load_vertex_isDelta(camBuf, startCamBuff + vertex_size * i) == 0 && load_vertex_isDelta(camBuf, startCamBuff + vertex_size * (i-1)) == 0{
                sumRi += ri;
            }
            i -= 1;
        }

        return(1.0 / (1.0 + sumRi))
    }

    fn MISWeightS1(camBuf: DeviceBuffer, _lightBuf: DeviceBuffer, pixel:i32, t:i32, light_pdf : EmissivePdf, mat: Material, sampled: Vertex) -> f32{
        let startCamBuff = vertex_size * pixel * max_path_len;
        //let startLightBuf = vertex_size * pixel * max_path_len_light;
        let pt = if t > 0 {load_vertex(camBuf, startCamBuff + vertex_size * (t-1))} else {make_empty_Vertex()};
        let ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + vertex_size * (t-2))} else {make_empty_Vertex()};
        let qs = sampled;

        let mut sumRi : f32 = 0.0;

        let mut ri :f32 = 1.0;

        if pt.valid != 0 && t - 1 > 1{
            let ptPdfRev = pdfLightDirect(qs, pt, light_pdf); //TODO check
            ri *= misSaveDiv(ptPdfRev, pt.pdfFwd);
            if ptMinus.isDelta == 0{ // we can just check ptMinus here because pt will allways be non Delta because its definded that way
                sumRi += ri;
            }
        }

        if ptMinus.valid != 0 && t - 2 > 1{
            let ptMinusPdfRev = pdfConectionGround(pt, qs, ptMinus, mat);
            ri *= misSaveDiv(ptMinusPdfRev, ptMinus.pdfFwd);
            if ptMinus.isDelta == 0 && load_vertex_isDelta(camBuf, startCamBuff + vertex_size * (t-3)) == 0{
                sumRi += ri;
            }
        }

        //this could be wrong???
        let mut i = t-3;
        while i > 1{
            ri *= misSaveDiv(load_vertex_pdfRev(camBuf, startCamBuff + vertex_size * i), load_vertex_pdfFwd(camBuf, startCamBuff + vertex_size * i));
            if load_vertex_isDelta(camBuf, startCamBuff + vertex_size * i) == 0 && load_vertex_isDelta(camBuf, startCamBuff + vertex_size * (i-1)) == 0{
                sumRi += ri;
            }
            i -= 1;
        }

        ri = 1.0;

        let qsPdfRev = pdfConectionGround(pt, ptMinus, qs, mat);
        ri *= misSaveDiv(qsPdfRev, qs.pdfFwd);
        //TODO no check for delta is needed here because delta is set to false for qs
        sumRi += ri;

        return(1.0 / (1.0 + sumRi))
    }

    fn MISWeightCamera(camBuf: DeviceBuffer, lightBuf: DeviceBuffer, pixel:i32, s:i32, t:i32, mat: Material) -> Vec2{
        let startCamBuff = vertex_size * pixel * max_path_len;
        let startLightBuf = vertex_size * pixel * max_path_len_light;

        let qs = load_vertex(lightBuf, startLightBuf + vertex_size * (s-1));
        let pt = if t > 0 {load_vertex(camBuf, startCamBuff + vertex_size * (t-1))} else {make_empty_Vertex()};
        //let qsMinus = load_vertex(lightBuf, startLightBuf + vertex_size * (s-2));
        let ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + vertex_size * (t-2))} else {make_empty_Vertex()};

        let mut ri1 : f32 = 0.0;

        if ptMinus.valid != 0 && t - 2 > 1{
            let ptMinusPdfRev = pdfConectionGround(pt, qs, ptMinus, mat);
            ri1 = misSaveDiv(ptMinusPdfRev, ptMinus.pdfFwd);
        }


        let qsPdfRev = pdfConectionGround(pt, ptMinus, qs, mat);
        let ri2 : f32 = misSaveDiv(qsPdfRev, qs.pdfFwd);

        return (make_vec2(ri1, ri2))
    }

    fn MISWeight(camBuf: DeviceBuffer, lightBuf: DeviceBuffer, pixel:i32, s:i32, t:i32, mat: Material, _contri: f32, current_ri: Vec2) -> f32{ //the contri is only
        let startCamBuff = vertex_size * pixel * max_path_len;
        let startLightBuf = vertex_size * pixel * max_path_len_light;

        let qs = load_vertex(lightBuf, startLightBuf + vertex_size * (s-1));
        let pt = if t > 0 {load_vertex(camBuf, startCamBuff + vertex_size * (t-1))} else {make_empty_Vertex()};
        let qsMinus = load_vertex(lightBuf, startLightBuf + vertex_size * (s-2));
        let ptMinus = if t > 1 {load_vertex(camBuf, startCamBuff + vertex_size * (t-2))} else {make_empty_Vertex()};

        let mut sumRi : f32 = 0.0;

        let mut ri :f32 = 1.0;

        if pt.valid != 0 && t - 1 > 1{
            let ptPdfRev = pdfConectionGround(qs, qsMinus, pt, mat); //this is most likly wrong 
            ri *= misSaveDiv(ptPdfRev, pt.pdfFwd);
            if ptMinus.isDelta == 0{ // we can just check ptMinus here because pt will allways be non Delta because its definded that way
                sumRi += ri;
            }
        }
        if ptMinus.valid != 0 && t - 2 > 1{
            ri *= current_ri.x;
            if ptMinus.isDelta == 0 && load_vertex_isDelta(camBuf, startCamBuff + vertex_size * (t-3)) == 0{//TODO t-3 should always exist
                sumRi += ri;
            }
        }

        let mut i = t-3;

        while i > 1{
            ri *= misSaveDiv(load_vertex_pdfRev(camBuf, startCamBuff + vertex_size * i), load_vertex_pdfFwd(camBuf, startCamBuff + vertex_size * i)); //Extra check here
            if load_vertex_isDelta(camBuf, startCamBuff + vertex_size * i) == 0 && load_vertex_isDelta(camBuf, startCamBuff + vertex_size * (i-1)) == 0{
                sumRi += ri;
            }
            i -= 1;
        }

        ri = 1.0;
        
        ri *= current_ri.y;
        if qsMinus.isDelta == 0{
            sumRi += ri;
        }

        let qsMinusPdfRev = pdfConectionGround(qs, pt, qsMinus, mat);
        ri *= misSaveDiv(qsMinusPdfRev, qsMinus.pdfFwd);
        if qsMinus.isDelta == 0 && (s-3 < 0 || (load_vertex_isDelta(lightBuf, startLightBuf + vertex_size * (s-3)) == 0)){//TODO check here
            sumRi += ri;
        }   

        i = s-3;

        while i > -1{
            ri *= misSaveDiv(load_vertex_pdfRev(lightBuf, startLightBuf + vertex_size * i), load_vertex_pdfFwd(lightBuf, startLightBuf + vertex_size * i)); //Extra check here
            if load_vertex_isDelta(lightBuf, startLightBuf + vertex_size * i) == 0 && (i-1 < 0 || (load_vertex_isDelta(lightBuf, startLightBuf + vertex_size * (i-1)) == 0)){//TODO check here
                sumRi += ri;
            }
            i -= 1;
        }

        return(1.0 / (1.0 + sumRi))
    }
    
    


    fn @on_shadow( ctx: ShadingContext
                 , rnd: &mut RndState
                 , payload: RayPayload
                 , secondary_payloads: RayPayload
                 , mat: Material
                 ) -> ShadowRay {
        
        if light_selector.count == 0{
            return(ShadowRay::None)
        }

        let pt = unwrap_biraypayload(payload);
        let surf = ctx.surf;
        let ray = ctx.ray;
        let pixel = ctx.pixel;

        if pt.depth >= max_path_len {
            return(ShadowRay::None)
        }

        let light_buf_pos  = vertex_size * pixel * max_path_len_light;

        let light_path_len = load_vertex_valid(buf, light_buf_pos);

        let choice = if light_path_len == 0 {1} else {pick_light_id(rnd, light_path_len) + 1};
        let s = choice;

        let t = pt.depth + 1;

        let s_choice_pdf = if light_path_len > 0 {light_path_len as f32} else {1};
        if s == -1 && light_path_len > 0{ //Todo this last part ist only for testing and needs to be deleted
            let choice_s = 2;

            let light_buf_pos_corrected = light_buf_pos + vertex_size * (choice_s - 1);

            let light_vertex = load_vertex(buf, light_buf_pos_corrected);
            let light_point = light_vertex.pos;

            let cam_pos = camera.get_pos();
            let cam_dir = vec3_sub(light_point, cam_pos);

            write_secondarypayload(secondary_payloads, SecondaryPayload {
                s=choice_s,
                t=-1,
                ri=make_vec2(0.0, 0.0),
                light_wo=make_vec3(0.0, 0.0, 0.0),
                camera_pos=make_vec3(0.0, 0.0, 0.0),

            });
            make_advanced_shadow_ray(
                make_ray(cam_pos, cam_dir, offset, 1 - offset, ray_flag_light),
                make_color(1.0, 1.0, 1.0, 1.0),
                light_vertex.mat
            )
        } else if s == 1{
            let (light, light_select_pdf) = light_selector.sample(rnd, ctx.surf.point); //TODO change to the more modern version
            let sample_direct = light.sample_direct;
            let light_sample  = @sample_direct(rnd, surf);


            if light.infinite{
                return(ShadowRay::None)
            }else{
                if light_sample.pdf.value <= flt_eps{ //pdf is Pos/Area
                    return(ShadowRay::None)
                }
                let light_dir = vec3_sub(light_sample.pos, surf.point);
                let light_dist = vec3_len(light_dir);
                let wi = vec3_mulf(light_dir, 1/light_dist);
                let wo = vec3_neg(ray.dir);

                let vis = vec3_dot(light_dir, surf.local.col(2));

                if vis > flt_eps && light_sample.cos > flt_eps{
                    let conection_dir = vec3_sub(light_sample.pos, surf.point);
                    let conection_ray = make_ray(light_sample.pos, conection_dir, 0, flt_max, ray_flag_bounce);

                    let light_normal = light_sample.normal; 
                    let tex_coords = light_sample.tex_coords;
                    let prim_coords = light_sample.prim_coords;

                    let light_surf = SurfaceElement{
                        is_entering = true,
                        point = light_sample.pos,
                        face_normal = light_normal,
                        inv_area = 1, //TODO this is wrong but should not matter 
                        prim_coords = prim_coords,
                        tex_coords = tex_coords,
                        local = make_orthonormal_mat3x3(light_normal)
                    };

                    let pdf_em = light.pdf_emission(conection_ray, light_surf);

                    let light_beta = color_mulf(light_sample.intensity, 1/light_select_pdf); //light intensity semms to already have pdf applyed

                    let f = mat.bsdf.eval(wi, wo);
                    let contri = color_mul(color_mul(light_beta, pt.contrib), f);

                    let mut sampled = make_empty_Vertex();
                    sampled.valid = 1;
                    sampled.pos = light_sample.pos;
                    sampled.beta = light_beta;
                    sampled.normal = light_sample.normal;
                    let mut pt_vertex = make_empty_Vertex();

                    //this should be enough but im not quit sure 
                    pt_vertex.valid = 1;
                    pt_vertex.pos = surf.point;


                    sampled.pdfFwd = pdfLightOrigin(sampled, pt_vertex, pdf_em, light_select_pdf);//is the order corect here?//and dont we need corection
                    //i hope we dont need the normal!!!!

                    let mis = MISWeightS1(camera_buf, buf, pixel, t, pdf_em, mat, sampled);
                    let mis_choice = mis * s_choice_pdf;

                    let mis_contri = color_mulf(contri, mis_choice);
                    
                    get_aov(1).splat(ctx.pixel, contri);

                    write_secondarypayload(secondary_payloads, SecondaryPayload {
                        s=s,
                        t=t,
                        ri=make_vec2(0.0, 0.0),
                        light_wo=make_vec3(0.0, 0.0, 0.0),
                        camera_pos=make_vec3(0.0, 0.0, 0.0),

                    });
                    return(make_simple_shadow_ray(
                        make_ray(surf.point, light_dir, offset, 1 - offset, ray_flag_light),
                        mis_contri
                    ))
                }else{
                    return(ShadowRay::None)
                }
            }
        }else if s > 1{
            let camera_pos = surf.point;
            let camera_wo = vec3_neg(ray.dir);
            let camera_beta = pt.contrib;

            let light_buf_pos_corrected = light_buf_pos + vertex_size * (s - 1);

            let light_vertex = load_vertex(buf, light_buf_pos_corrected);

            let light_pos = light_vertex.pos;
            let light_normal = light_vertex.normal;
            let light_wi = light_vertex.wo;
            //let light_uv = light_vertex.uv;

            let light_dir = vec3_sub(light_pos, camera_pos);
            let light_dist = vec3_len(light_dir);

            let camera_wi = vec3_mulf(light_dir, 1/light_dist);
            let light_wo = vec3_neg(camera_wi);
            
            let vis_camera = vec3_dot(camera_wi, surf.face_normal);
            let vis_camera2 = vec3_dot(camera_wo, surf.face_normal);
            let vis_light = vec3_dot(light_wo, light_normal);
            let vis_light2 = vec3_dot(light_wi, light_normal);

            if vis_camera > flt_eps && vis_camera2 > flt_eps && vis_light > flt_eps && vis_light2 > flt_eps{ 
                // let light_surf = SurfaceElement{
                //     is_entering = true,
                //     point = light_pos,
                //     face_normal = light_normal,
                //     inv_area = 1, //TODO this is wrong but should not matter 
                //     prim_coords = make_vec2(0,0),
                //     tex_coords = make_vec2(light_uv.x, light_uv.y),
                //     local = make_orthonormal_mat3x3(light_normal)
                // };

                let camera_bsdf = mat.bsdf.eval(camera_wi, camera_wo);
                let importance = color_mulf(color_mul(camera_bsdf, camera_beta),s_choice_pdf); //we add s_choice_pdf here because other wise we would need more memory 
                let current_ri = MISWeightCamera(camera_buf, buf, pixel, s, t, mat);

                write_secondarypayload(secondary_payloads, SecondaryPayload {
                    s=s,
                    t=t,
                    ri=current_ri,
                    light_wo=light_wo,
                    camera_pos=camera_pos,
                });
                return(make_advanced_shadow_ray(
                    make_ray(surf.point, light_dir, offset, 1 - offset, ray_flag_light),
                    importance,
                    light_vertex.mat
                ))
            }else{
                ShadowRay::None
            }
        }else{
            ShadowRay::None
        }
    }

    fn @make_miss_contri_shadingContext(pixel : i32, hitPLight : Vec3, hitPCam : Vec3, normal : Vec3) -> ShadingContext{
        let dir = vec3_sub(hitPLight, hitPCam);
        let ray = make_ray(hitPLight, dir, offset, flt_max, ray_flag_light);
        let hit = make_hit(0, 0, vec3_dist(hitPLight, hitPCam), make_vec2(0,0));
        let uvw = make_vec3(0,0,0);
        let surf = SurfaceElement{
            is_entering = false,
            point = hitPLight,
            face_normal = normal,
            inv_area = 0.0,
            prim_coords = make_vec2(0,0),
            tex_coords = make_vec2(0,0),
            local = make_orthonormal_mat3x3(normal)
        };
        ShadingContext{
            entity_id = 0,
            pixel = pixel,
            ray = ray,
            hit = hit,
            surf = surf,
            uvw = uvw
        }
    }


    fn @on_shadow_miss( _ray: Ray
        , pixel: i32
        , shader: MaterialShader
        , payload: RayPayload
        , color: Color) -> Option[Color] {
            let secondary = unwrap_secondarypayload(payload);
            let s = secondary.s;
            let t = secondary.t;

            let new_pixel = if pixel < 0 {0} else {pixel};
            let light_buf_pos  = vertex_size * new_pixel * max_path_len_light;

            if t == -1{
                let light_buf_pos_corrected = light_buf_pos + vertex_size * (s - 1);

                let light_vertex = load_vertex(buf, light_buf_pos_corrected);
                let pixelCord = camera.get_pixel(light_vertex.pos, width, height);
                let light_pos = light_vertex.pos;
                let light_normal = light_vertex.normal;

                let camera_pos = camera.get_pos();
                let cam_dir = vec3_normalize(vec3_sub(camera_pos, light_pos));

                let ctx = make_miss_contri_shadingContext(new_pixel, light_pos, camera_pos, light_normal);
                let mat = shader(ctx);

                let light_bsdf = mat.bsdf.eval(cam_dir, light_vertex.wo);
                let camera_pdf = camera.get_pdf();
                let contri = color_mulf(color_mul(light_bsdf, light_vertex.beta), camera_pdf);

                let linear_pixel = pixelCord.linear;
                if linear_pixel != -1{
                    get_aov(0).splat(linear_pixel, contri);
                    //get_aov(0).splat(nlinear_pixel, make_color(1.0, 1.0, 1.0, 1.0));
                    Option[Color]::None
                } else{
                    Option[Color]::None
                }
            } else if s > 1{
                let light_buf_pos_corrected = light_buf_pos + vertex_size * (secondary.s - 1);

                let light_vertex = load_vertex(buf, light_buf_pos_corrected);

                let light_pos = light_vertex.pos;
                let light_normal = light_vertex.normal;
                let light_beta = light_vertex.beta;
                let light_wi = light_vertex.wo;

                let light_dir = vec3_sub(light_pos, secondary.camera_pos);
                let light_dist = vec3_len(light_dir);
                let light_dist2 = light_dist * light_dist;

                let ctx = make_miss_contri_shadingContext(new_pixel, light_pos, secondary.camera_pos, light_normal);
                let mat = shader(ctx);

                let light_bsdf = mat.bsdf.eval(secondary.light_wo, light_wi);

                let geom_factor = 1 / light_dist2; //the two cos factors should be in in the two bsdf calculations

                let conection = color_mulf(light_bsdf, geom_factor);
                let contri = color_mul(color_mul(conection, color), light_beta);

                let mis = MISWeight(camera_buf, buf, new_pixel, secondary.s, secondary.t, mat, contri.r, secondary.ri); //the solution could change here because we added s_choice already

                get_aov(s).splat(ctx.pixel, contri); 

                let mis_contri = color_mulf(contri, mis);
                make_option(mis_contri)
            }else{
                make_option(color)
            }

    }



    fn @on_hit( ctx: ShadingContext
              , payload: RayPayload
              , mat: Material
              ) -> Option[Color] {
        let pt = unwrap_biraypayload(payload);
        let surf = ctx.surf;
        let ray = ctx.ray;
        let pixel = ctx.pixel;
        let t = pt.depth + 1;

        let wo = vec3_neg(ray.dir);
        let buf_pos = vertex_size * pixel * max_path_len;

        let beta = pt.contrib;

        let mut pdfFwd = if pt.depth == 1 {1.0} else {pt.mis};
        let mut current_isDelta = 0;

        if mat.bsdf.is_specular{
            pdfFwd = 0.0;
            current_isDelta = 1;
        }
        
        let current_buf_pos = buf_pos + pt.depth * vertex_size;
        let prev_buf_pos = buf_pos + (pt.depth - 1) * vertex_size;

        let current_pos = surf.point;
        let current_normal = surf.face_normal;
        
        let prev_vertex     = load_vertex(camera_buf, prev_buf_pos);
        let prev_pos        = if pt.depth == 1 {ray.org} else {prev_vertex.pos};
        
        let correctedFwdPDF = convertDensity(prev_pos, current_pos, current_normal, pdfFwd);
        
        let current_vertex = Vertex {
            valid =      1,
            mat =        mat.id,
            pdfFwd =     correctedFwdPDF,
            pdfRev =     0.0,
            pos =        current_pos,
            normal =     current_normal,
            beta =       beta,
            wo =         wo,
            isDelta =    current_isDelta,
            uv =         make_vec3(surf.prim_coords.x, surf.prim_coords.y, 1.0)

        };
        store_vertex(camera_buf, current_buf_pos, current_vertex);

        // Hits on a light source
        if mat.is_emissive && surf.is_entering {
            let out_dir = vec3_neg(ray.dir);
            let dot     = vec3_dot(out_dir, surf.local.col(2));
            if dot > flt_eps { // Only contribute proper aligned directions
                let emit     = mat.emission(ctx);
                let light   = mat.light;

                let conection_dir = vec3_sub(surf.point, prev_pos);
                let conection_ray = make_ray(surf.point, conection_dir, 0, flt_max, ray_flag_bounce);

                let pdf_em = light.pdf_emission(conection_ray, surf); //TODO check connection Ray
                
                let contrib = color_mul(pt.contrib, emit.intensity);

                let mis = MISWeightS0(camera_buf, buf, pixel, t, pdf_lightpick, pdf_em);

                //get_aov(0).splat(ctx.pixel, contrib);
                return(make_option(color_mulf(contrib,mis)))
            }
        }
        Option[Color]::None
    }


    fn @on_miss( _ray: Ray
               , _pixel: i32
               , _payload: RayPayload) -> Option[Color] {
        Option[Color]::None
    }

    fn @on_bounce( ctx: ShadingContext
                , rnd: &mut RndState
                , payload: RayPayload
                , mat: Material
                 ) -> Option[Ray] {
        let pt = unwrap_biraypayload(payload);
        let surf = ctx.surf;
        let ray = ctx.ray;
        let pixel = ctx.pixel;

        if pt.depth >= max_path_len {
            return(Option[Ray]::None)
        }

        let buf_pos = vertex_size * pixel * max_path_len;
        let prev_buf_pos = buf_pos + (pt.depth - 1) * vertex_size;

        let wo = vec3_neg(ray.dir);
        let beta = pt.contrib;
        let current_pos = surf.point;

        if let Option[BsdfSample]::Some(mat_sample) = mat.bsdf.sample(rnd, wo, false) {
            let next_pdf = mat_sample.pdf;
            if next_pdf == 0.0{
                return(Option[Ray]::None)
            }

            let mut next_contri = color_mul(beta, mat_sample.color); //cos and pdf is already applied

            let rr_prob = russian_roulette_pbrt(color_mulf(next_contri, pt.eta * pt.eta), 0.95);
            if randf(rnd) >= rr_prob {
                return(Option[Ray]::None)
            }
            next_contri = color_mulf(next_contri, 1 / rr_prob);

            let prev_vertex     = load_vertex(camera_buf, prev_buf_pos);

            let prev_pos        = if pt.depth == 1 {ray.org} else {prev_vertex.pos};
            let prev_normal     = prev_vertex.normal;

            let mut correctedRevPDF : f32 = 0.0;
            let pdfRev = if mat.bsdf.is_specular {0.0} else {mat.bsdf.pdf(mat_sample.in_dir, wo)}; //this could be wrong!!!!

            if pt.depth != 1{
                correctedRevPDF = convertDensity(current_pos, prev_pos, prev_normal, pdfRev);
            }

            store_vertex_pdfRev(camera_buf, prev_buf_pos, correctedRevPDF);
            
            write_biraypayload(payload, BIRayPayload {
                mis = next_pdf,
                contrib = next_contri,
                depth = pt.depth + 1,
                eta = pt.eta * mat_sample.eta
            });
            make_option(make_ray(surf.point, mat_sample.in_dir, offset, flt_max, ray_flag_bounce))
        } else {
            Option[Ray]::None
        }
    }
    //the Secondary_payload could be smaller
    Technique {
        on_hit         = on_hit,
        on_miss        = on_miss,
        on_shadow      = on_shadow,
        on_bounce      = on_bounce,
        on_shadow_hit  = TechniqueNoShadowHitFunction,
        on_shadow_miss = on_shadow_miss
    }
}
