fn @convertDensity(current_pos: Vec3, next_pos: Vec3, next_normal: Vec3, pdf: f32) -> f32{
    let w       = vec3_sub(next_pos, current_pos);
    let dist2   = vec3_dot(w, w);
    let dist    = math_builtins::sqrt(dist2);
    let dir     = vec3_mulf(w , 1 / dist);

    let out_pdf = pdf * absolute_cos(next_normal, dir) / dist2;
    out_pdf
}


fn @make_light_renderer(buf: DeviceBuffer, max_path_len_light: i32) -> Technique  {
    let offset:f32 = 0.001;

    fn @on_bounce( ctx: ShadingContext
        , rnd: &mut RndState
        , payload: RayPayload
        , mat: Material
                    ) -> Option[Ray] {
        let pt = unwrap_ptraypayload(payload);
        let ray = ctx.ray;
        let surf = ctx.surf;
        let pixel = ctx.pixel;
        
        //TODO is that at the right position or should it be further down?
        if pt.depth >= max_path_len_light {
            return(Option[Ray]::None)
        }

        //aov_stats.splat(pixel, make_color(if pt.depth == 1 { 2 } else { 1 }, 0, 0));

        // Bounce
        let wo       = vec3_neg(ray.dir);
        let buf_pos  = vertex_size * pixel * max_path_len_light;
        //TODO check wo?
        if let Option[BsdfSample]::Some(mat_sample) = mat.bsdf.sample(rnd, wo, true) {
            let mut beta   = pt.contrib;
            let mut pdfFwd = pt.inv_pdf;//the use of inv_pdf is a bit strange here

            let current_buf_pos = buf_pos + pt.depth * vertex_size;
            let prev_buf_pos = buf_pos + (pt.depth - 1) * vertex_size;

            if pt.depth == 1{ //TODO we assume here that the fist hit is state.dpeth == 1 this has to be tested
                let start_vertex = load_vertex(buf, current_buf_pos);  

                pdfFwd     = start_vertex.pdfFwd;
                beta       = start_vertex.beta;
            }

            let mut pdfRev = mat.bsdf.pdf(mat_sample.in_dir, wo); //this could be wrong!!!!

            let current_pos     = surf.point;
            let current_normal  = surf.face_normal;

            let prev_vertex = load_vertex(buf, prev_buf_pos);

            let prev_pos        = prev_vertex.pos;
            let prev_normal     = prev_vertex.normal;

            let correctedFwdPDF = convertDensity(prev_pos, current_pos, current_normal, pdfFwd);
            let correctedRevPDF = convertDensity(current_pos, prev_pos, prev_normal, pdfRev);
            
            let mut current_isDelta = 0;

            if mat.bsdf.is_specular{
                current_isDelta = 1;
                pdfRev = 0.0;
                pdfFwd = 0.0;
            }
;
            let current_uv      = make_vec3(surf.prim_coords.x, surf.prim_coords.y, 1.0);

            store_vertex_pdfRev(buf, prev_buf_pos, correctedRevPDF);
            store_vertex_valid(buf, buf_pos, pt.depth + 1);//this means the first pixel position indicates the depth

            //The current size of one data point is vertex_size bytes (valid: i32 (0, 1): 0, material: i32: 1, pdfFwd: f32 : 2, pdfRev: f32: 3, pos: vec3 : 4, normal: vec3 : 7, beta: vec3 : 10, wo: vec3 : 13)
            store_vertex_data(buf, current_buf_pos, 1, mat.id, correctedFwdPDF, 0.0, current_pos, current_normal, beta, wo, current_isDelta, current_uv);

            let next_pdf = mat_sample.pdf;
            if next_pdf == 0.0{ //TODO better use Epsilon?
                return(Option[Ray]::None)
            }
            let next_contri = color_mul(beta, mat_sample.color); //cos and pdf is already applied

            write_ptraypayload(payload, PTRayPayload {
                inv_pdf = next_pdf,
                contrib = next_contri,
                depth = pt.depth + 1,
                eta = pt.eta * mat_sample.eta
            });
            make_option(make_ray(surf.point, mat_sample.in_dir, offset, flt_max, ray_flag_bounce))
            // make_option(
            //     make_ray(surf.point, mat_sample.in_dir, offset, flt_max, ray_flag_bounce),
            //     wrap_ptraypayload(PTRayPayload {
            //         mis = next_pdf,
            //         contrib = next_contri,
            //         depth = pt.depth + 1,
            //         eta  = pt.eta * mat_sample.eta
            //     })
            // )
        } else {
            Option[Ray]::None
        }
    }

    Technique {
        on_hit    = TechniqueNoHitFunction,
        on_miss   = TechniqueNoMissFunction,
        on_shadow = TechniqueNoShadowFunction,
        on_bounce      = on_bounce,
        on_shadow_hit  = TechniqueNoShadowHitFunction,
        on_shadow_miss = TechniqueNoShadowMissFunction
    }
}


