// Compute scale based on horizontal field of view and aspect ratio (w/h)
fn @compute_scale_from_hfov(fov: f32, aspect: f32) -> Vec2 {
    let sw = math_builtins::tan(fov / 2);
    let sh = sw / aspect;
    make_vec2(sw, sh)
}

// Compute scale based on vertical field of view and aspect ratio (w/h)
fn @compute_scale_from_vfov(fov: f32, aspect: f32) -> Vec2 {
    let sh = math_builtins::tan(fov / 2);
    let sw = sh * aspect;
    make_vec2(sw, sh)
}

// Creates a perspective camera
fn @make_perspective_camera(eye: Vec3, dir: Vec3, up: Vec3, scale: Vec2, tmin: f32, tmax: f32) -> Camera {
    let right = vec3_normalize(vec3_cross(dir, up));
    let view  = make_mat3x3(right, up, dir);
    let inv_view = mat3x3_invert(view);

    Camera {
        generate_ray = @ |_, coord| {
            let d = vec3_normalize(mat3x3_mul(view, make_vec3(scale.x * coord.nx, scale.y * coord.ny, 1)));
            make_ray(eye, d, tmin, tmax, ray_flag_camera)
        },
        differential = @ |_| {
            (
                vec3_mulf(right, scale.x),
                vec3_mulf(up, scale.y)
            )
        },
        get_pixel = @ |pos, width, height| {
            let dir = vec3_normalize(vec3_sub(pos, eye));
            let view_space_dir = vec3_normalize(mat3x3_mul(inv_view, dir));
            let image_plane_pos = make_vec2((view_space_dir.x / view_space_dir.z) / scale.x, (view_space_dir.y /view_space_dir.z) / scale.y);

            let raw_x = ((image_plane_pos.x + 1.0)/2.0);
            let raw_y = ((1.0 - image_plane_pos.y)/2.0);

            let x =  math_builtins::floor((raw_x * width as f32) - 0.5 + 0.5) as i32; //we use - 0.5 to get to the midel of the pixel but then use + 0.5 to round with floor, the compiler should compile this away
            let y =  math_builtins::floor((raw_y * height as f32) - 0.5 + 0.5) as i32;

            if x < 0 || x >= width || y < 0 || y >= height || view_space_dir.z <= 0.0 { //if view_space_dir.z is smaller than 0.0 it should mean that the position is behind the camera
                return(make_invalid_pixelcoord())
            }

            let linear = y * width + x;

            PixelCoord {
                x = x,
                y = y,
                linear = linear,
                nx = view_space_dir.x,
                ny = view_space_dir.y
            }
        },
        get_pos = @ || eye,
        get_pdf = @ || scale.x * scale.y
    }
}

// Creates a perspective camera with depth of field
fn @make_perspective_dof_camera(eye: Vec3, dir: Vec3, up: Vec3, scale: Vec2, aperture_radius: f32, focal_length: f32, tmin: f32, tmax: f32) -> Camera {
    let right = vec3_normalize(vec3_cross(dir, up));
    let view  = make_mat3x3(right, up, dir);

    Camera {
        generate_ray = @ |rnd, coord| {
            let global_dir = vec3_normalize(mat3x3_mul(view, make_vec3(scale.x * coord.nx, scale.y * coord.ny, 1)));
            let focus_pos  = vec3_mulf(global_dir, focal_length);

            let aperature_coord = vec2_mulf(square_to_concentric_disk(make_vec2(randf(rnd), randf(rnd))), aperture_radius);
            let aperature_pos   = mat3x3_mul(view, make_vec3(aperature_coord.x, aperature_coord.y, 0));
            let d               = vec3_normalize(vec3_sub(focus_pos, aperature_pos));

            make_ray(vec3_add(eye, aperature_pos), d, tmin, tmax, ray_flag_camera)
        },
        differential = @ |_| {
            (
                // TODO: We ignore the lens effect here
                vec3_mulf(right, scale.x),
                vec3_mulf(up, scale.y)
            )
        },
        get_pixel = @ |_| make_empty_pixelcoord(),
        get_pos = @ || eye,
        get_pdf = @ || 0.0
    }
}